# TODO
- Check figures and tables for positioning and make sure its at the bottom or top of a page
- Converting to ASL introduction paragraph is bad.... like really bad 

# Fault Simulations
\subsection{Generating Test Vectors using Vecgen}
When performing logic or fault simulations test vectors must be created to stimulate the circuit and record the response.  In AUSIM these vectors are written out in a very verbose method where each line of a file is an individual test vector.  For large circuits such as the SSA BIST which require many test vectors these files can be large and error prone when created manually.  Vecgen is a program written to generate AUSIM vector files.  It uses a straight forward command language to build a test vector file of any length.  It is written in Microsoft's .NET C\#\cite{csharp} language.  As it is only important in the context of test vector generation only a brief overview of Vecgen will be given here.

Vecgen uses the concept of frames to simplify the creation of test vector files.  Instead of requiring each individual test vector (which may include a large number of duplicate bits), Vecgen only stores the changes between test vectors.  An example of a vecgen file is shown in Table \ref{tbl:vecgen_example}, this simple example will generate four test vectors each 2 bits wide.  

---Old Crap 
that changes in test vectors be recorded.  The first line of a Vecgen file must be the GENERATE command which tells the generator how many (vectors) to generate and the number of primary inputs of the circuit.  If all the user provides is the GENERATE command then Vecgen will create a vector file with the specified number of vectors, filled with all `0' characters as wide as the number of primary inputs in the circuit.  This is the idea behind Vecgen, the vector each time is the same as the vector before it unless changed by the user in a frame.  There are a number of commands which are available to manipulate the output using Vecgen (the full list is available in Appendix \ref{apdx:Vecgen}).  An example generation command file, which would create the vector file shown in Table \ref{tbl:half_adder_vector}, is given in Table \ref{tbl:Vecgen_example} showing the Vecgen format:
\begin{table}
	\label{tbl:vecgen_example}
	\begin{center}
		\begin{tabular}{l}
			GENERATE 4 2 \\		
			\\
			FRAME 1	\\
			BIT 0 1	\\
			\\
			FRAME 2	\\
			BIT 0 0	\\
			BIT 1 1	\\
			\\
			FRAME 3	\\
			BIT 0 1	\\
		\end{tabular}
	\end{center}
	\caption{Command to generate the half-adder vector sequence}
\end{table}
In the case of the half-adder example, the generator is much more verbose and would not be preferred; however, for this example one can see how it would help in more complex generation.  In our example FRAME 0 is not modified since the first vector generated is always all logic 0's.  FRAME 1 changes bit 0 to a logic 1 so that the resulting vector is now \textit{01}.  FRAME 2 changes bit 0 back to a logic 0 and changes bit 1 to a logic 1, resulting in \textit{10}.  Finally FRAME 3 updates bit 0 back to a logic 1 to obtain the vector \textit{11}.  Only at the times the output vector is changing does a FRAME need to be declared: if we were to generate ten frames instead of the four specified in the example, then the remaining six vectors would be automatically filled in and be the same \textit{11} vector set by FRAME 3.

This is a very simple example, there are many more commands as shown in Appendix \ref{apdx:Vecgen} that allow for much more powerful generation.  Some commands such as RANGE affect multiple bits at once, others such as SERIALIZE or CLOCK work over multiple frames.  One interesting command is the DECLARE command.  The DECLARE command creates a reusable group of commands which can be called from any frame.  This is especially useful if a certain sequence is required repeatedly during a test.  An example sequence and its output are shown in Table \ref{tbl:countsequence}.  The sequence creates a clock on its MSB, then calls a function which counts up then counts back down.  It then disables the clock and calls the counter function again.
\begin{table}
	\caption{Vecgen Example}
	\begin{center}
		\begin{tabular}{l|r|r}
		Commands & 1-15 & 16-24 \\ \hline
		GENERATE 24 3 & 100 & 001 \\
		 & 000 & 000 \\
		\textbf{DECLARE} counter & 101 & 000 \\
		FRAME 0	& 001 & 001 \\
		COUNT 0 2 U & 110 & 001 \\
		FRAME 8 & 010 & 010 \\
		COUNT 0 2 D & 111 & 010 \\
		\textbf{ENDDECLARE} & 011 & 011 \\ 
		 & 100 & 011 \\
 		\textbf{FRAME 0} & 000 & \\
		CLOCK 2 & 111 &  \\
		CALL counter & 011 & \\
		\textbf{FRAME 16} & 110 & \\
		BIT 2 0 & 010 &  \\
		CALL counter & 101 & \\
		\end{tabular}
	\end{center}
	\label{tbl:countsequence}
\end{table}
The generation in Table \ref{tbl:countsequence} is much more powerful than the previous example in Table \ref{tbl:Vecgen_example} and demonstrates some of the power that the Vecgen program provides.  All fault simulation tests for the BIST are designed in the Vecgen markup language for simplicity.
